/**
 * This project was part of the summer semester Term course for computer security and privacy.
 *
 * @author Lennart Hahner
 */
package org.wearables.randomizedresponse.differentialprivacy.decoder;

import com.google.common.hash.HashFunction;
import com.google.common.hash.Hashing;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import jakarta.validation.constraints.PositiveOrZero;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.TreeMap;
import java.util.concurrent.ExecutionException;
import org.springframework.stereotype.Service;
import org.springframework.validation.annotation.Validated;
import org.wearables.randomizedresponse.differentialprivacy.parameter.ParameterService;

/**
 * Pipeline step that debiases aggregated results by mapping candidate value ranges into Bloom
 * filter indexes and converting them into a design matrix. The resulting design matrix is later
 * used for regression analysis to recover unbiased class distributions.
 *
 * @param <T> The entity type to be processed
 */
@Service
@Validated
public class DebiasPipe<T> implements Pipe<T> {
  /**
   * Executes the debiasing step of the pipeline.
   *
   * <p>This method builds a bin map, calculates Bloom filter indexes, converts them into a design
   * matrix, and updates the substance.
   *
   * @param substance The container holding entities and decoding metadata
   * @return The updated substance with bin map, indexes, and design matrix
   */
  @Override
  public Substance<T> process(@NotNull Substance<T> substance) throws ExecutionException {
    Map<String, int[]> binMap = buildBinMap(substance.getMaxRange(), substance.getRangeIterator());
    substance.setBinMap(binMap);
    int[] indexes =
        mapCandidateStringsToIndex(
            substance.getStartRange(),
            substance.getMaxRange(),
            substance.getMessageBitSize(),
            null);
    substance.setIndexes(indexes);
    double[][] designMatrix =
        convertClassesToArray(binMap, substance.getMessageBitSize(), substance.getRangeIterator());
    substance.setDesignMatrix(designMatrix);
    return substance;
  }

  /**
   * Builds a mapping of value ranges to Bloom filter indexes.
   *
   * <p>Each range is represented as a string key (for example "0-10") and mapped to an array of bit
   * positions in the Bloom filter. Ranges are generated by stepping through the maximum range using
   * the iterator size.
   *
   * @param maxRange The upper bound of the value range
   * @param rangeIterator Step size used to divide the range into bins
   * @return Map of string range labels to arrays of Bloom filter indexes
   * @throws IllegalArgumentException If rangeIterator or maxRange are invalid
   */
  public Map<String, int[]> buildBinMap(@PositiveOrZero int maxRange, @Positive int rangeIterator) {
    int messageBitSize = new ParameterService().getDefaultParameterEntity().messageBitSize;
    Map<String, int[]> binMap = new HashMap<>();
    int previousRange = 0;
    do {
      int nextRange = previousRange + rangeIterator;
      String range = Integer.toString(previousRange) + "-" + Integer.toString(nextRange);
      binMap.put(range, mapCandidateStringsToIndex(previousRange, nextRange, messageBitSize, null));
      previousRange = nextRange;
    } while (previousRange < maxRange);
    return binMap;
  }

  /**
   * Maps a candidate range into Bloom filter indexes using hash functions.
   *
   * <p>By default, Murmur3 hashes with fixed seeds are used unless a custom hash function is
   * provided.
   *
   * @param startRange Starting value of the range
   * @param endRange Ending value of the range
   * @param bloomFilterSize Size of the Bloom filter bit array
   * @param hashFunction Optional custom hash function; null to use defaults
   * @return Array of Bloom filter indexes for the given range
   * @throws ArrayIndexOutOfBoundsException If a calculated index exceeds the Bloom filter size
   */
  public int[] mapCandidateStringsToIndex(
      @PositiveOrZero int startRange,
      @Positive int endRange,
      @Positive int bloomFilterSize,
      HashFunction hashFunction) {
    int firstHashSeed = 0x12345678;
    HashFunction firstDefaultHashFunction = Hashing.murmur3_128(firstHashSeed);
    int secondHashSeed = 0x9ABCDEF0;
    HashFunction secondDefaultHashfunction = Hashing.murmur3_128(secondHashSeed);
    if (hashFunction != null) {
      firstDefaultHashFunction = hashFunction;
      secondDefaultHashfunction = hashFunction;
    }
    String binRange = String.valueOf(startRange) + '-' + endRange;
    byte[] keyBytes = binRange.getBytes(StandardCharsets.UTF_8);
    int i1 = firstDefaultHashFunction.hashBytes(keyBytes).asInt();
    int i2 = secondDefaultHashfunction.hashBytes(keyBytes).asInt();

    int[] indexes = new int[2];
    for (int t = 0; t < 2; t++) {
      indexes[t] = Math.floorMod(i1 + t * i2, bloomFilterSize);
      if (indexes[t] > bloomFilterSize) {
        throw new ArrayIndexOutOfBoundsException("Index out of range");
      }
    }
    Arrays.sort(indexes);
    return indexes;
  }

  /**
   * Converts the bin map into a design matrix.
   *
   * <p>Each row of the matrix corresponds to a range, and each column to a Bloom filter bit. A
   * value of 1 indicates that the bit index belongs to the range.
   *
   * @param binMap Mapping of ranges to Bloom filter indexes
   * @param messageBitSize Size of the Bloom filter bit array
   * @param rangeIterator Step size used to divide ranges into bins
   * @return Two-dimensional array representing the design matrix
   */
  public double[][] convertClassesToArray(
      @NotNull Map<String, int[]> binMap,
      @Positive int messageBitSize,
      @Positive int rangeIterator) {
    TreeMap<String, int[]> treeBinMap = new TreeMap<>();
    if (!(binMap instanceof TreeMap<String, int[]>)) treeBinMap.putAll(binMap);
    double[][] designMatrix = new double[treeBinMap.size()][messageBitSize];
    int previousRange = 0;
    for (int i = 0; i < designMatrix.length; i++) {
      int nextRange = previousRange + rangeIterator;
      String range = Integer.toString(previousRange) + "-" + Integer.toString(nextRange);
      for (int t = 0; t < treeBinMap.get(range).length; t++) {
        designMatrix[i][treeBinMap.get(range)[t]] = 1;
      }
      previousRange = nextRange;
    }
    return designMatrix;
  }
}
